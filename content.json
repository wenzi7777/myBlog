[{"title":"使用Cloudflare Worker來進行Firebase代理","path":"2022/07/19/使用Cloudflare Worker來進行Firebase代理/","text":"使用Cloudflare Worker代理Firebase連結 最近有一個專案使用Firebase來存儲用戶們上傳的圖片檔，但是Firebase在中國大陸是被防火長城阻擋的，因此中國大陸的使用者無法查看圖片 於是，就有了本篇Blog 這篇Blog會教你如何使用Cloudflare提供的免費的Worker服務，來建立一個Proxy，然後無論來自哪個地方的人都可以通過代理的連結正常訪問Firebase的檔案。 順帶一提： 文章末尾有在下搭建好的代理連結，各位也可以使用在下的Proxy，免去自己搭建的麻煩！！ 首先需要一個Cloudflare帳戶，如果沒有可以去註冊一個 -&gt; 0、 Cloudflare官方網站的連結 -&gt; 1、登入後，進入你的控制台 -&gt; 2、選定左邊的Worker -&gt; 3、再點選「建立服務」注意這裡選定「Http處理常式」即可 -&gt; 4、點選「快速編輯」！我們不使用Cli進行編輯，因為這屬於簡單的任務，使用Cli反而浪費時間 -&gt; 5、開始編寫代理服務！簡單介紹一下什麼是Cloudflare WorkerCloudflare Worker其實是Cloudflare提供的一個極其輕量的雲端伺服器，它的基本功能就是能夠接受請求，進行處理後返回數據&#x2F;網頁等等資源。Cloudflare Worker是免費使用的（免費計畫），並且大多數情況下，免費計畫就已經能夠滿足我們的大部分需求。 -&gt; 6、能夠透過Worker訪問被封鎖的Firebase的原理上文提到，Firebase在中國大陸被封鎖。但是Worker並未被封鎖，並且Worker能夠正常訪問Firebase，因此就可以實現以下邏輯。使用者透過向Worker發起請求（請求）-&gt; Worker接受請求，並讀取請求內需要代理訪問的地址 -&gt; Worker訪問地址得到資源 -&gt; 返回給來源 -&gt; 7、源代碼及部分代碼源自網路，對於本專案的需求，在下進行了更改適配。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416addEventListener(&quot;fetch&quot;, event =&gt; &#123; event.passThroughOnException(); if (event.request.method === &#x27;GET&#x27;) &#123; const url = new URL(event.request.url); const accept = event.request.headers.get(&#x27;Accept&#x27;); if (url.pathname.startsWith(&#x27;/firebasestorage.googleapis.com/&#x27;)) &#123; // 將請求轉發給原伺服器 event.respondWith(proxyRequest(&#x27;https:/&#x27; + url.pathname + url.search, event.request)); &#125; else if (accept &amp;&amp; (accept.indexOf(&#x27;text/html&#x27;) &gt;= 0 || accept.indexOf(&#x27;text/css&#x27;) &gt;= 0)) &#123; if (url.pathname.startsWith(&#x27;/firebasestorage.googleapis.com/&#x27;)) &#123; event.respondWith(proxyStylesheet(&#x27;https:/&#x27; + url.pathname + url.search, event.request)); &#125; else &#123; event.respondWith(processRequest(event.request, event)); &#125; &#125; &#125;&#125;);const VALID_CHARSETS = [&#x27;utf-8&#x27;, &#x27;utf8&#x27;, &#x27;iso-8859-1&#x27;, &#x27;us-ascii&#x27;];async function proxyRequest(url, request) &#123; let init = &#123; method: request.method, headers: &#123;&#125; &#125;; // 只允許這些Headers const proxyHeaders = [&quot;Accept&quot;, &quot;Accept-Encoding&quot;, &quot;Accept-Language&quot;, &quot;Referer&quot;, &quot;User-Agent&quot;]; for (let name of proxyHeaders) &#123; let value = request.headers.get(name); if (value) &#123; init.headers[name] = value; &#125; &#125; // 使用源ip新建 X-Forwarded-For 請求頭 const clientAddr = request.headers.get(&#x27;cf-connecting-ip&#x27;); if (clientAddr) &#123; init.headers[&#x27;X-Forwarded-For&#x27;] = clientAddr; &#125; const response = await fetch(url, init); if (response) &#123; const responseHeaders = [&quot;Content-Type&quot;, &quot;Cache-Control&quot;, &quot;Expires&quot;, &quot;Accept-Ranges&quot;, &quot;Date&quot;, &quot;Last-Modified&quot;, &quot;ETag&quot;]; let responseInit = &#123;status: response.status, statusText: response.statusText, headers: &#123;&#125;&#125;; for (let name of responseHeaders) &#123; let value = response.headers.get(name); if (value) &#123; responseInit.headers[name] = value; &#125; &#125; responseInit.headers[&#x27;X-Content-Type-Options&#x27;] = &quot;nosniff&quot;; const newResponse = new Response(response.body, responseInit); return newResponse; &#125; return response;&#125;async function proxyStylesheet(url, request) &#123; let css = await fetchCSS(url, request) if (css) &#123; const responseInit = &#123;headers: &#123; &quot;Content-Type&quot;: &quot;text/css; charset=utf-8&quot;, &quot;Cache-Control&quot;: &quot;private, max-age=86400, stale-while-revalidate=604800&quot; &#125;&#125;; const newResponse = new Response(css, responseInit); return newResponse; &#125; else &#123; return proxyRequest(url, request); &#125;&#125;async function processRequest(request, event) &#123; const response = await fetch(request); if (response &amp;&amp; response.status === 200) &#123; const contentType = response.headers.get(&quot;content-type&quot;); if (contentType &amp;&amp; contentType.indexOf(&quot;text/html&quot;) !== -1) &#123; return await processHtmlResponse(response, event.request, event); &#125; else if (contentType &amp;&amp; contentType.indexOf(&quot;text/css&quot;) !== -1) &#123; return await processStylesheetResponse(response, event.request, event); &#125; &#125; return response;&#125;async function processHtmlResponse(response, request, event) &#123; const contentType = response.headers.get(&quot;content-type&quot;); const charsetRegex = /charset\\s*=\\s*([^\\s;]+)/mgi; const match = charsetRegex.exec(contentType); if (match !== null) &#123; let charset = match[1].toLowerCase(); if (!VALID_CHARSETS.includes(charset)) &#123; return response; &#125; &#125; let embedStylesheet = true; let csp = response.headers.get(&quot;Content-Security-Policy&quot;); if (csp) &#123; let ok = false; let cspRule = null; const styleRegex = /style-src[^;]*/gmi; let match = styleRegex.exec(csp); if (match !== null) &#123; cspRule = match[0]; &#125; else &#123; const defaultRegex = /default-src[^;]*/gmi; let match = defaultRegex.exec(csp); if (match !== null) &#123; cspRule = match[0]; &#125; &#125; if (cspRule !== null) &#123; if (cspRule.indexOf(&quot;&#x27;unsafe-inline&#x27;&quot;) &gt;= 0) &#123; ok = true; embedStylesheet = true; &#125; else if (cspRule.indexOf(&quot;&#x27;self&#x27;&quot;) &gt;= 0) &#123; ok = true; embedStylesheet = false; &#125; &#125; if (!ok) &#123; return response; &#125; &#125; const &#123; readable, writable &#125; = new TransformStream(); const newResponse = new Response(readable, response); modifyHtmlStream(response.body, writable, request, event, embedStylesheet); return newResponse;&#125;async function processStylesheetResponse(response, request, event) &#123; let body = response.body; try &#123; body = await response.text(); const fontCSSRegex = /@import\\s*(url\\s*)?[\\(&#x27;&quot;\\s]+((https?:)?\\/\\/fonts.googleapis.com\\/css[^&#x27;&quot;\\)]+)[\\s&#x27;&quot;\\)]+\\s*;/mgi; let match = fontCSSRegex.exec(body); while (match !== null) &#123; const matchString = match[0]; const fontCSS = await fetchCSS(match[2], request, event); if (fontCSS.length) &#123; body = body.split(matchString).join(fontCSS); fontCSSRegex.lastIndex -= matchString.length - fontCSS.length; &#125; match = fontCSSRegex.exec(body); &#125; &#125; catch (e) &#123;&#125; const newResponse = new Response(body, response); return newResponse;&#125;function chunkContainsInvalidCharset(chunk) &#123; let invalid = false; const charsetRegex = /&lt;\\s*meta[^&gt;]+charset\\s*=\\s*[&#x27;&quot;]([^&#x27;&quot;]*)[&#x27;&quot;][^&gt;]*&gt;/mgi; const charsetMatch = charsetRegex.exec(chunk); if (charsetMatch) &#123; const docCharset = charsetMatch[1].toLowerCase(); if (!VALID_CHARSETS.includes(docCharset)) &#123; invalid = true; &#125; &#125; const contentTypeRegex = /&lt;\\s*meta[^&gt;]+http-equiv\\s*=\\s*[&#x27;&quot;]\\s*content-type[^&gt;]*&gt;/mgi; const contentTypeMatch = contentTypeRegex.exec(chunk); if (contentTypeMatch) &#123; const metaTag = contentTypeMatch[0]; const metaRegex = /charset\\s*=\\s*([^\\s&quot;]*)/mgi; const metaMatch = metaRegex.exec(metaTag); if (metaMatch) &#123; const charset = metaMatch[1].toLowerCase(); if (!VALID_CHARSETS.includes(charset)) &#123; invalid = true; &#125; &#125; &#125; return invalid;&#125;async function modifyHtmlStream(readable, writable, request, event, embedStylesheet) &#123; const reader = readable.getReader(); const writer = writable.getWriter(); const encoder = new TextEncoder(); let decoder = new TextDecoder(&quot;utf-8&quot;, &#123;fatal: true&#125;); let firstChunk = true; let unsupportedCharset = false; let partial = &#x27;&#x27;; let content = &#x27;&#x27;; try &#123; for(;;) &#123; const &#123; done, value &#125; = await reader.read(); if (done) &#123; if (partial.length) &#123; partial = await modifyHtmlChunk(partial, request, event, embedStylesheet); await writer.write(encoder.encode(partial)); partial = &#x27;&#x27;; &#125; break; &#125; let chunk = null; if (unsupportedCharset) &#123; await writer.write(value); continue; &#125; else &#123; try &#123; chunk = decoder.decode(value, &#123;stream:true&#125;); &#125; catch (e) &#123; unsupportedCharset = true; if (partial.length) &#123; await writer.write(encoder.encode(partial)); partial = &#x27;&#x27;; &#125; await writer.write(value); continue; &#125; &#125; try &#123; if (firstChunk) &#123; firstChunk = false; if (chunkContainsInvalidCharset(chunk)) &#123; // switch to passthrough unsupportedCharset = true; if (partial.length) &#123; await writer.write(encoder.encode(partial)); partial = &#x27;&#x27;; &#125; await writer.write(value); continue; &#125; &#125; content = partial + chunk; partial = &#x27;&#x27;; const linkPos = content.lastIndexOf(&#x27;&lt;link&#x27;); if (linkPos &gt;= 0) &#123; const linkClose = content.indexOf(&#x27;/&gt;&#x27;, linkPos); if (linkClose === -1) &#123; partial = content.slice(linkPos); content = content.slice(0, linkPos); &#125; &#125; if (content.length) &#123; content = await modifyHtmlChunk(content, request, event, embedStylesheet); &#125; &#125; catch (e) &#123;&#125; if (content.length) &#123; await writer.write(encoder.encode(content)); content = &#x27;&#x27;; &#125; &#125; &#125; catch(e) &#123;&#125; try &#123; await writer.close(); &#125; catch(e) &#123;&#125;&#125;async function modifyHtmlChunk(content, request, event, embedStylesheet) &#123; const fontCSSRegex = /&lt;link\\s+[^&gt;]*href\\s*=\\s*[&#x27;&quot;]((https?:)?\\/\\/fonts.googleapis.com\\/css[^&#x27;&quot;]+)[^&gt;]*&gt;/mgi; let match = fontCSSRegex.exec(content); while (match !== null) &#123; const matchString = match[0]; if (matchString.indexOf(&#x27;stylesheet&#x27;) &gt;= 0) &#123; if (embedStylesheet) &#123; const fontCSS = await fetchCSS(match[1], request, event); if (fontCSS.length) &#123; // See if there is a media type on the link tag let mediaStr = &#x27;&#x27;; const mediaMatch = matchString.match(/media\\s*=\\s*[&#x27;&quot;][^&#x27;&quot;]*[&#x27;&quot;]/mig); if (mediaMatch) &#123; mediaStr = &#x27; &#x27; + mediaMatch[0]; &#125; // Replace the actual css let cssString = &quot;&lt;style&quot; + mediaStr + &quot;&gt;\\n&quot;; cssString += fontCSS; cssString += &quot;\\n&lt;/style&gt;\\n&quot;; content = content.split(matchString).join(cssString); fontCSSRegex.lastIndex -= matchString.length - cssString.length; &#125; &#125; else &#123; // Rewrite the URL to proxy it through the origin let originalUrl = match[1]; let startPos = originalUrl.indexOf(&#x27;/fonts.googleapis.com&#x27;); let newUrl = originalUrl.substr(startPos); let newString = matchString.split(originalUrl).join(newUrl); content = content.split(matchString).join(newString); fontCSSRegex.lastIndex -= matchString.length - newString.length; &#125; match = fontCSSRegex.exec(content); &#125; &#125; return content;&#125;var FONT_CACHE = &#123;&#125;;async function fetchCSS(url, request) &#123; let fontCSS = &quot;&quot;; if (url.startsWith(&#x27;/&#x27;)) url = &#x27;https:&#x27; + url; const userAgent = request.headers.get(&#x27;user-agent&#x27;); const clientAddr = request.headers.get(&#x27;cf-connecting-ip&#x27;); const browser = getCacheKey(userAgent); const cacheKey = browser ? url + &#x27;&amp;&#x27; + browser : url; const cacheKeyRequest = new Request(cacheKey); let cache = null; let foundInCache = false; if (cacheKey in FONT_CACHE) &#123; // hit in the memory cache fontCSS = FONT_CACHE[cacheKey]; foundInCache = true; &#125; else &#123; // Try pulling it from the cache API (wrap it in case it&#x27;s not implemented) try &#123; cache = caches.default; let response = await cache.match(cacheKeyRequest); if (response) &#123; fontCSS = await response.text(); foundInCache = true; &#125; &#125; catch(e) &#123; // Ignore the exception &#125; &#125; if (!foundInCache) &#123; let headers = &#123;&#x27;Referer&#x27;: request.url&#125;; if (browser) &#123; headers[&#x27;User-Agent&#x27;] = userAgent; &#125; else &#123; headers[&#x27;User-Agent&#x27;] = &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)&quot;; &#125; if (clientAddr) &#123; headers[&#x27;X-Forwarded-For&#x27;] = clientAddr; &#125; try &#123; const response = await fetch(url, &#123;headers: headers&#125;); if (response &amp;&amp; response.status === 200) &#123; fontCSS = await response.text(); fontCSS = fontCSS.replace(/(https?:)?\\/\\/fonts\\.gstatic\\.com\\//mgi, &#x27;/fonts.gstatic.com/&#x27;); FONT_CACHE[cacheKey] = fontCSS; try &#123; if (cache) &#123; const cacheResponse = new Response(fontCSS, &#123;ttl: 86400&#125;); event.waitUntil(cache.put(cacheKeyRequest, cacheResponse)); &#125; &#125; catch(e) &#123;&#125; &#125; &#125; catch(e) &#123;&#125; &#125; return fontCSS;&#125;function getCacheKey(userAgent) &#123; let os = &#x27;&#x27;; const osRegex = /^[^(]*\\(\\s*(\\w+)/mgi; let match = osRegex.exec(userAgent); if (match) &#123; os = match[1]; &#125; let mobile = &#x27;&#x27;; if (userAgent.match(/Mobile/mgi)) &#123; mobile = &#x27;Mobile&#x27;; &#125; const edgeRegex = /\\s+Edge\\/(\\d+)/mgi; match = edgeRegex.exec(userAgent); if (match) &#123; return &#x27;Edge&#x27; + match[1] + os + mobile; &#125; const chromeRegex = /\\s+Chrome\\/(\\d+)/mgi; match = chromeRegex.exec(userAgent); if (match) &#123; return &#x27;Chrome&#x27; + match[1] + os + mobile; &#125; const webkitRegex = /\\s+AppleWebKit\\/(\\d+)/mgi; match = webkitRegex.exec(userAgent.match); if (match) &#123; return &#x27;WebKit&#x27; + match[1] + os + mobile; &#125; const firefoxRegex = /\\s+Firefox\\/(\\d+)/mgi; match = firefoxRegex.exec(userAgent); if (match) &#123; return &#x27;Firefox&#x27; + match[1] + os + mobile; &#125; return null;&#125; 現在即可使用，方法是例如我要訪問https://firebasestorage.googleapis.com/v0/b/mikuproject-e9478.appspot.com/o/mikuproject-files%2F404.png?alt=media&amp;token=40bb05e9-d925-48a4-b4f5-800a28153b92現在只要在連結的https:&#x2F;&#x2F;後，加上你的Worker的域名即可更改後的連結變為https://objectproxy.1205.moe/firebasestorage.googleapis.com/v0/b/mikuproject-e9478.appspot.com/o/mikuproject-files%2F404.png?alt=media&amp;token=40bb05e9-d925-48a4-b4f5-800a28153b92 現成的作業 Worker: https://objectproxy.1205.moe/"},{"title":"在Vue程式中使用Electron框架","path":"2022/05/01/在Vue程序中使用Electron框架/","text":"在Vue程式中使用Electron框架 今天禿然遇到一個需求，即構建跨平台的應用程式，那麼對於我一個全棧開發來說，使用Electron就是最好的選擇了。 瞭解一下，什麼是Electron Electron 是一個開源 JavaScript 框架，用於使用 Web 技術（HTML、CSS 和 JavaScript）構建跨平台的應用程序。 這意味著如果您事先熟悉使用這些技術，您可以直接使用原先的源代碼構建成Windows、Linux 和 macOS 的桌面應用程序。 背後，Electron 將 Chromium 引擎與 Node.js 運行時環境相結合，來運行您的程式。 而且，已有許多知名以Electron構建的程式，比如 Slack、VS Code 和 WhatsApp Desktop。 那麼，依照與我的本次實踐，來告訴各位小貓咪如何使用Electron構建基於Vue的App -&gt; 0、最基本的安裝npm（不需要講了吧www） -&gt; 1、安裝vue cli 1npm install -g @vue/cli 全局安裝vue cli -&gt; 2、使用vue create指令新建一個項目 1vue create your-project 新建一個名字是your-project的項目 -&gt; 3、使用vue add命令新增一個插件 1vue add electron-builder 將名字是electron-builder的插件加入你的項目!注意，您需要cd入您的項目目錄後方可執行這條命令 -&gt; 4、運行程式 1npm run electron:serve 開啟應用程式!注意，您需要cd入您的項目目錄後方可執行這條命令!注意，若有錯誤您可以嘗試執行 npm i 現在即可進行開發 如何打包成可以分發的應用程式呢？ 其實很簡單，在需要打包成對應應用程式的平台內執行： 1npm run electron:build 現在即可完成這個應用的開發！"},{"title":"轉義","path":"2022/04/13/轉義/","text":"轉義 由於學習JavaScript時是依照實際案例來學習的，因此遺漏了某些少用到的方面。 最近在實現一個需求時，發現轉義符真的超好用！！下面是需求詳情： -&gt;需要向伺服器內存入html片段，並且這些html片段有行內樣式，如下圖 12345&#123; &quot;title&quot;:&quot;SPRING&quot;, &quot;honor&quot;:&quot;&lt;span style=&#x27;color: blue;&#x27;&gt;SPRING&lt;/span&gt;&quot;, &quot;description&quot;:&quot;代表您加入了SPRING計畫&quot;&#125; 發現問題🤔：在這裏單引號，雙引號都用上了，那麼要如何才能在SQL語句內拼上這段字符串呢？ 超級重要！！！ -&gt; SQL語句需要被一對引號括起來。 有的小貓咪可能就會說了，用模板字符串(``)不就可以了嗎？ 其實是不行的，請看這張圖 這裡使用單引號、雙引號都會報錯 -&gt; 所以這裡的解決方案就是：轉義符號給出正確的SQL語句 1UPDATE items SET itemValue =&#x27;&#123;&quot;title&quot;:&quot;SPRING&quot;,&quot;honor&quot;:&quot;&lt;span style=\\&#x27;color: blue;\\&#x27;&gt;SPRING&lt;/span&gt;&quot;,&quot;description&quot;:&quot;代表您加入了SPRING計畫&quot;&#125;&#x27; WHERE itemKey=&quot;UID1*ActivatedHonor&quot; 成功！"},{"title":"用css實現網頁高斯模糊特效","path":"2022/02/21/用css實現網頁高斯模糊背景/","text":"用css實現網頁高斯模糊特效 Attention: 這篇文章探討的是如何實現背景高斯模糊，而不是整個視圖高斯模糊！！！ 大概效果是這樣： 沒有高斯模糊 使用高斯模糊效果 怎麼樣？？是不是感覺好漂亮的效果，那麼如何實現呢(¯︶¯) 先來看看DOM結構其實有兩種方法，這是方法一，相容性較好！ -&gt; 外層有一個 id&#x3D;animeDetails 的Div標籤，用於撐起整個頁面的高度123#animeDetails &#123; height: 100%;&#125; -&gt; 內層使用了 class&#x3D;animeDetails_mask 的一個Div標籤用於放入要展示的內容，例如現在我放入的是contents這幾個字123456.animeDetails_mask &#123; position: relative; /* 讓這個div能夠占滿畫面 */ height: 100%; /* 撐起整個頁面的高度 */ overflow: hidden; /* 溢出的內容隱藏 */ z-index: 1; /* 高於它的偽元素高度 */&#125; -&gt; 現在開始設定背景圖及高斯模糊，用到了偽元素唷（≧∇≦） 12345678910111213.animeDetails_mask::before &#123; content: &quot;&quot;; /* 偽元素使用content: &quot;&quot;指定內容為空白，以保持這個偽元素可見（被撐開了，不然沒有內容height=0）。 */ position: absolute; /* 設定佔滿畫面 開始 */ top: -100px; left: -100px; right: -100px; bottom: -100px; /* 設定佔滿畫面 結束 */ background-image: url(&quot;https://www.dmoe.cc/random.php&quot;); /* 用來設定背景圖，這個url是一個免費的隨機二次元圖片api */ background-repeat: no-repeat; /* 設定背景圖為不重複 */ background-size: cover; /* 設定背景圖的展示樣式 */ filter: blur(16px); /* 設定高斯模糊16px */ z-index: -1; /* 以免擋到文本 */ &#125; !!!終於，完成惹，來看看效果吧 好像，真的有高斯模糊了，但是為什麼圖會不透明度這麼低，讓我怎麼看字啊！ 對惹！在 Div.animeDetails_mask 上設定背景色就好了吧！ 不管用欸，這是怎麼回事呢？ 其實答案很簡單， ::before 使用了position: absolute，已經在文檔流最上方了，會吧後面的背景色遮住。 解決方案就是，用 ::after 設定背景色 12345678910.animeDetails_mask::after &#123; content: &quot;&quot;; /* 偽元素使用content: &quot;&quot;指定內容為空白，以保持這個偽元素可見（被撐開了，不然沒有內容height=0）。 */ position: absolute; /* 設定佔滿畫面 開始 */ top: -100px; left: -100px; right: -100px; bottom: -100px; /* 設定佔滿畫面 結束 */ background-color: rgba(255, 255, 255, .9); /* 設定背景色，來讓高斯模糊能有白色的底 */ z-index: -1; /* 以免擋到文本 */&#125; -&gt; 成果預覽 另一種實現方法與FireFox不相容 -&gt; 給 #animeDetails 設定背景圖-&gt; 給 .animeDetails_mask 設定樣式 1backdrop-filter: blur(16px); 同樣能完成"}]