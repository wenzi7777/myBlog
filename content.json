[{"title":"ä½¿ç”¨Cloudflare Workerä¾†é€²è¡ŒFirebaseä»£ç†","path":"2022/07/19/ä½¿ç”¨Cloudflare Workerä¾†é€²è¡ŒFirebaseä»£ç†/","text":"ä½¿ç”¨Cloudflare Workerä»£ç†Firebaseé€£çµ æœ€è¿‘æœ‰ä¸€å€‹å°ˆæ¡ˆä½¿ç”¨Firebaseä¾†å­˜å„²ç”¨æˆ¶å€‘ä¸Šå‚³çš„åœ–ç‰‡æª”ï¼Œä½†æ˜¯Firebaseåœ¨ä¸­åœ‹å¤§é™¸æ˜¯è¢«é˜²ç«é•·åŸé˜»æ“‹çš„ï¼Œå› æ­¤ä¸­åœ‹å¤§é™¸çš„ä½¿ç”¨è€…ç„¡æ³•æŸ¥çœ‹åœ–ç‰‡ æ–¼æ˜¯ï¼Œå°±æœ‰äº†æœ¬ç¯‡Blog é€™ç¯‡Blogæœƒæ•™ä½ å¦‚ä½•ä½¿ç”¨Cloudflareæä¾›çš„å…è²»çš„Workeræœå‹™ï¼Œä¾†å»ºç«‹ä¸€å€‹Proxyï¼Œç„¶å¾Œç„¡è«–ä¾†è‡ªå“ªå€‹åœ°æ–¹çš„äººéƒ½å¯ä»¥é€šéä»£ç†çš„é€£çµæ­£å¸¸è¨ªå•Firebaseçš„æª”æ¡ˆã€‚ é †å¸¶ä¸€æï¼š æ–‡ç« æœ«å°¾æœ‰åœ¨ä¸‹æ­å»ºå¥½çš„ä»£ç†é€£çµï¼Œå„ä½ä¹Ÿå¯ä»¥ä½¿ç”¨åœ¨ä¸‹çš„Proxyï¼Œå…å»è‡ªå·±æ­å»ºçš„éº»ç…©ï¼ï¼ é¦–å…ˆéœ€è¦ä¸€å€‹Cloudflareå¸³æˆ¶ï¼Œå¦‚æœæ²’æœ‰å¯ä»¥å»è¨»å†Šä¸€å€‹ -&gt; 0ã€ Cloudflareå®˜æ–¹ç¶²ç«™çš„é€£çµ -&gt; 1ã€ç™»å…¥å¾Œï¼Œé€²å…¥ä½ çš„æ§åˆ¶å° -&gt; 2ã€é¸å®šå·¦é‚Šçš„Worker -&gt; 3ã€å†é»é¸ã€Œå»ºç«‹æœå‹™ã€æ³¨æ„é€™è£¡é¸å®šã€ŒHttpè™•ç†å¸¸å¼ã€å³å¯ -&gt; 4ã€é»é¸ã€Œå¿«é€Ÿç·¨è¼¯ã€ï¼æˆ‘å€‘ä¸ä½¿ç”¨Clié€²è¡Œç·¨è¼¯ï¼Œå› ç‚ºé€™å±¬æ–¼ç°¡å–®çš„ä»»å‹™ï¼Œä½¿ç”¨Cliåè€Œæµªè²»æ™‚é–“ -&gt; 5ã€é–‹å§‹ç·¨å¯«ä»£ç†æœå‹™ï¼ç°¡å–®ä»‹ç´¹ä¸€ä¸‹ä»€éº¼æ˜¯Cloudflare WorkerCloudflare Workerå…¶å¯¦æ˜¯Cloudflareæä¾›çš„ä¸€å€‹æ¥µå…¶è¼•é‡çš„é›²ç«¯ä¼ºæœå™¨ï¼Œå®ƒçš„åŸºæœ¬åŠŸèƒ½å°±æ˜¯èƒ½å¤ æ¥å—è«‹æ±‚ï¼Œé€²è¡Œè™•ç†å¾Œè¿”å›æ•¸æ“š&#x2F;ç¶²é ç­‰ç­‰è³‡æºã€‚Cloudflare Workeræ˜¯å…è²»ä½¿ç”¨çš„ï¼ˆå…è²»è¨ˆç•«ï¼‰ï¼Œä¸¦ä¸”å¤§å¤šæ•¸æƒ…æ³ä¸‹ï¼Œå…è²»è¨ˆç•«å°±å·²ç¶“èƒ½å¤ æ»¿è¶³æˆ‘å€‘çš„å¤§éƒ¨åˆ†éœ€æ±‚ã€‚ -&gt; 6ã€èƒ½å¤ é€éWorkerè¨ªå•è¢«å°é–çš„Firebaseçš„åŸç†ä¸Šæ–‡æåˆ°ï¼ŒFirebaseåœ¨ä¸­åœ‹å¤§é™¸è¢«å°é–ã€‚ä½†æ˜¯Workerä¸¦æœªè¢«å°é–ï¼Œä¸¦ä¸”Workerèƒ½å¤ æ­£å¸¸è¨ªå•Firebaseï¼Œå› æ­¤å°±å¯ä»¥å¯¦ç¾ä»¥ä¸‹é‚è¼¯ã€‚ä½¿ç”¨è€…é€éå‘Workerç™¼èµ·è«‹æ±‚ï¼ˆè«‹æ±‚ï¼‰-&gt; Workeræ¥å—è«‹æ±‚ï¼Œä¸¦è®€å–è«‹æ±‚å…§éœ€è¦ä»£ç†è¨ªå•çš„åœ°å€ -&gt; Workerè¨ªå•åœ°å€å¾—åˆ°è³‡æº -&gt; è¿”å›çµ¦ä¾†æº -&gt; 7ã€æºä»£ç¢¼åŠéƒ¨åˆ†ä»£ç¢¼æºè‡ªç¶²è·¯ï¼Œå°æ–¼æœ¬å°ˆæ¡ˆçš„éœ€æ±‚ï¼Œåœ¨ä¸‹é€²è¡Œäº†æ›´æ”¹é©é…ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416addEventListener(&quot;fetch&quot;, event =&gt; &#123; event.passThroughOnException(); if (event.request.method === &#x27;GET&#x27;) &#123; const url = new URL(event.request.url); const accept = event.request.headers.get(&#x27;Accept&#x27;); if (url.pathname.startsWith(&#x27;/firebasestorage.googleapis.com/&#x27;)) &#123; // å°‡è«‹æ±‚è½‰ç™¼çµ¦åŸä¼ºæœå™¨ event.respondWith(proxyRequest(&#x27;https:/&#x27; + url.pathname + url.search, event.request)); &#125; else if (accept &amp;&amp; (accept.indexOf(&#x27;text/html&#x27;) &gt;= 0 || accept.indexOf(&#x27;text/css&#x27;) &gt;= 0)) &#123; if (url.pathname.startsWith(&#x27;/firebasestorage.googleapis.com/&#x27;)) &#123; event.respondWith(proxyStylesheet(&#x27;https:/&#x27; + url.pathname + url.search, event.request)); &#125; else &#123; event.respondWith(processRequest(event.request, event)); &#125; &#125; &#125;&#125;);const VALID_CHARSETS = [&#x27;utf-8&#x27;, &#x27;utf8&#x27;, &#x27;iso-8859-1&#x27;, &#x27;us-ascii&#x27;];async function proxyRequest(url, request) &#123; let init = &#123; method: request.method, headers: &#123;&#125; &#125;; // åªå…è¨±é€™äº›Headers const proxyHeaders = [&quot;Accept&quot;, &quot;Accept-Encoding&quot;, &quot;Accept-Language&quot;, &quot;Referer&quot;, &quot;User-Agent&quot;]; for (let name of proxyHeaders) &#123; let value = request.headers.get(name); if (value) &#123; init.headers[name] = value; &#125; &#125; // ä½¿ç”¨æºipæ–°å»º X-Forwarded-For è«‹æ±‚é ­ const clientAddr = request.headers.get(&#x27;cf-connecting-ip&#x27;); if (clientAddr) &#123; init.headers[&#x27;X-Forwarded-For&#x27;] = clientAddr; &#125; const response = await fetch(url, init); if (response) &#123; const responseHeaders = [&quot;Content-Type&quot;, &quot;Cache-Control&quot;, &quot;Expires&quot;, &quot;Accept-Ranges&quot;, &quot;Date&quot;, &quot;Last-Modified&quot;, &quot;ETag&quot;]; let responseInit = &#123;status: response.status, statusText: response.statusText, headers: &#123;&#125;&#125;; for (let name of responseHeaders) &#123; let value = response.headers.get(name); if (value) &#123; responseInit.headers[name] = value; &#125; &#125; responseInit.headers[&#x27;X-Content-Type-Options&#x27;] = &quot;nosniff&quot;; const newResponse = new Response(response.body, responseInit); return newResponse; &#125; return response;&#125;async function proxyStylesheet(url, request) &#123; let css = await fetchCSS(url, request) if (css) &#123; const responseInit = &#123;headers: &#123; &quot;Content-Type&quot;: &quot;text/css; charset=utf-8&quot;, &quot;Cache-Control&quot;: &quot;private, max-age=86400, stale-while-revalidate=604800&quot; &#125;&#125;; const newResponse = new Response(css, responseInit); return newResponse; &#125; else &#123; return proxyRequest(url, request); &#125;&#125;async function processRequest(request, event) &#123; const response = await fetch(request); if (response &amp;&amp; response.status === 200) &#123; const contentType = response.headers.get(&quot;content-type&quot;); if (contentType &amp;&amp; contentType.indexOf(&quot;text/html&quot;) !== -1) &#123; return await processHtmlResponse(response, event.request, event); &#125; else if (contentType &amp;&amp; contentType.indexOf(&quot;text/css&quot;) !== -1) &#123; return await processStylesheetResponse(response, event.request, event); &#125; &#125; return response;&#125;async function processHtmlResponse(response, request, event) &#123; const contentType = response.headers.get(&quot;content-type&quot;); const charsetRegex = /charset\\s*=\\s*([^\\s;]+)/mgi; const match = charsetRegex.exec(contentType); if (match !== null) &#123; let charset = match[1].toLowerCase(); if (!VALID_CHARSETS.includes(charset)) &#123; return response; &#125; &#125; let embedStylesheet = true; let csp = response.headers.get(&quot;Content-Security-Policy&quot;); if (csp) &#123; let ok = false; let cspRule = null; const styleRegex = /style-src[^;]*/gmi; let match = styleRegex.exec(csp); if (match !== null) &#123; cspRule = match[0]; &#125; else &#123; const defaultRegex = /default-src[^;]*/gmi; let match = defaultRegex.exec(csp); if (match !== null) &#123; cspRule = match[0]; &#125; &#125; if (cspRule !== null) &#123; if (cspRule.indexOf(&quot;&#x27;unsafe-inline&#x27;&quot;) &gt;= 0) &#123; ok = true; embedStylesheet = true; &#125; else if (cspRule.indexOf(&quot;&#x27;self&#x27;&quot;) &gt;= 0) &#123; ok = true; embedStylesheet = false; &#125; &#125; if (!ok) &#123; return response; &#125; &#125; const &#123; readable, writable &#125; = new TransformStream(); const newResponse = new Response(readable, response); modifyHtmlStream(response.body, writable, request, event, embedStylesheet); return newResponse;&#125;async function processStylesheetResponse(response, request, event) &#123; let body = response.body; try &#123; body = await response.text(); const fontCSSRegex = /@import\\s*(url\\s*)?[\\(&#x27;&quot;\\s]+((https?:)?\\/\\/fonts.googleapis.com\\/css[^&#x27;&quot;\\)]+)[\\s&#x27;&quot;\\)]+\\s*;/mgi; let match = fontCSSRegex.exec(body); while (match !== null) &#123; const matchString = match[0]; const fontCSS = await fetchCSS(match[2], request, event); if (fontCSS.length) &#123; body = body.split(matchString).join(fontCSS); fontCSSRegex.lastIndex -= matchString.length - fontCSS.length; &#125; match = fontCSSRegex.exec(body); &#125; &#125; catch (e) &#123;&#125; const newResponse = new Response(body, response); return newResponse;&#125;function chunkContainsInvalidCharset(chunk) &#123; let invalid = false; const charsetRegex = /&lt;\\s*meta[^&gt;]+charset\\s*=\\s*[&#x27;&quot;]([^&#x27;&quot;]*)[&#x27;&quot;][^&gt;]*&gt;/mgi; const charsetMatch = charsetRegex.exec(chunk); if (charsetMatch) &#123; const docCharset = charsetMatch[1].toLowerCase(); if (!VALID_CHARSETS.includes(docCharset)) &#123; invalid = true; &#125; &#125; const contentTypeRegex = /&lt;\\s*meta[^&gt;]+http-equiv\\s*=\\s*[&#x27;&quot;]\\s*content-type[^&gt;]*&gt;/mgi; const contentTypeMatch = contentTypeRegex.exec(chunk); if (contentTypeMatch) &#123; const metaTag = contentTypeMatch[0]; const metaRegex = /charset\\s*=\\s*([^\\s&quot;]*)/mgi; const metaMatch = metaRegex.exec(metaTag); if (metaMatch) &#123; const charset = metaMatch[1].toLowerCase(); if (!VALID_CHARSETS.includes(charset)) &#123; invalid = true; &#125; &#125; &#125; return invalid;&#125;async function modifyHtmlStream(readable, writable, request, event, embedStylesheet) &#123; const reader = readable.getReader(); const writer = writable.getWriter(); const encoder = new TextEncoder(); let decoder = new TextDecoder(&quot;utf-8&quot;, &#123;fatal: true&#125;); let firstChunk = true; let unsupportedCharset = false; let partial = &#x27;&#x27;; let content = &#x27;&#x27;; try &#123; for(;;) &#123; const &#123; done, value &#125; = await reader.read(); if (done) &#123; if (partial.length) &#123; partial = await modifyHtmlChunk(partial, request, event, embedStylesheet); await writer.write(encoder.encode(partial)); partial = &#x27;&#x27;; &#125; break; &#125; let chunk = null; if (unsupportedCharset) &#123; await writer.write(value); continue; &#125; else &#123; try &#123; chunk = decoder.decode(value, &#123;stream:true&#125;); &#125; catch (e) &#123; unsupportedCharset = true; if (partial.length) &#123; await writer.write(encoder.encode(partial)); partial = &#x27;&#x27;; &#125; await writer.write(value); continue; &#125; &#125; try &#123; if (firstChunk) &#123; firstChunk = false; if (chunkContainsInvalidCharset(chunk)) &#123; // switch to passthrough unsupportedCharset = true; if (partial.length) &#123; await writer.write(encoder.encode(partial)); partial = &#x27;&#x27;; &#125; await writer.write(value); continue; &#125; &#125; content = partial + chunk; partial = &#x27;&#x27;; const linkPos = content.lastIndexOf(&#x27;&lt;link&#x27;); if (linkPos &gt;= 0) &#123; const linkClose = content.indexOf(&#x27;/&gt;&#x27;, linkPos); if (linkClose === -1) &#123; partial = content.slice(linkPos); content = content.slice(0, linkPos); &#125; &#125; if (content.length) &#123; content = await modifyHtmlChunk(content, request, event, embedStylesheet); &#125; &#125; catch (e) &#123;&#125; if (content.length) &#123; await writer.write(encoder.encode(content)); content = &#x27;&#x27;; &#125; &#125; &#125; catch(e) &#123;&#125; try &#123; await writer.close(); &#125; catch(e) &#123;&#125;&#125;async function modifyHtmlChunk(content, request, event, embedStylesheet) &#123; const fontCSSRegex = /&lt;link\\s+[^&gt;]*href\\s*=\\s*[&#x27;&quot;]((https?:)?\\/\\/fonts.googleapis.com\\/css[^&#x27;&quot;]+)[^&gt;]*&gt;/mgi; let match = fontCSSRegex.exec(content); while (match !== null) &#123; const matchString = match[0]; if (matchString.indexOf(&#x27;stylesheet&#x27;) &gt;= 0) &#123; if (embedStylesheet) &#123; const fontCSS = await fetchCSS(match[1], request, event); if (fontCSS.length) &#123; // See if there is a media type on the link tag let mediaStr = &#x27;&#x27;; const mediaMatch = matchString.match(/media\\s*=\\s*[&#x27;&quot;][^&#x27;&quot;]*[&#x27;&quot;]/mig); if (mediaMatch) &#123; mediaStr = &#x27; &#x27; + mediaMatch[0]; &#125; // Replace the actual css let cssString = &quot;&lt;style&quot; + mediaStr + &quot;&gt;\\n&quot;; cssString += fontCSS; cssString += &quot;\\n&lt;/style&gt;\\n&quot;; content = content.split(matchString).join(cssString); fontCSSRegex.lastIndex -= matchString.length - cssString.length; &#125; &#125; else &#123; // Rewrite the URL to proxy it through the origin let originalUrl = match[1]; let startPos = originalUrl.indexOf(&#x27;/fonts.googleapis.com&#x27;); let newUrl = originalUrl.substr(startPos); let newString = matchString.split(originalUrl).join(newUrl); content = content.split(matchString).join(newString); fontCSSRegex.lastIndex -= matchString.length - newString.length; &#125; match = fontCSSRegex.exec(content); &#125; &#125; return content;&#125;var FONT_CACHE = &#123;&#125;;async function fetchCSS(url, request) &#123; let fontCSS = &quot;&quot;; if (url.startsWith(&#x27;/&#x27;)) url = &#x27;https:&#x27; + url; const userAgent = request.headers.get(&#x27;user-agent&#x27;); const clientAddr = request.headers.get(&#x27;cf-connecting-ip&#x27;); const browser = getCacheKey(userAgent); const cacheKey = browser ? url + &#x27;&amp;&#x27; + browser : url; const cacheKeyRequest = new Request(cacheKey); let cache = null; let foundInCache = false; if (cacheKey in FONT_CACHE) &#123; // hit in the memory cache fontCSS = FONT_CACHE[cacheKey]; foundInCache = true; &#125; else &#123; // Try pulling it from the cache API (wrap it in case it&#x27;s not implemented) try &#123; cache = caches.default; let response = await cache.match(cacheKeyRequest); if (response) &#123; fontCSS = await response.text(); foundInCache = true; &#125; &#125; catch(e) &#123; // Ignore the exception &#125; &#125; if (!foundInCache) &#123; let headers = &#123;&#x27;Referer&#x27;: request.url&#125;; if (browser) &#123; headers[&#x27;User-Agent&#x27;] = userAgent; &#125; else &#123; headers[&#x27;User-Agent&#x27;] = &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)&quot;; &#125; if (clientAddr) &#123; headers[&#x27;X-Forwarded-For&#x27;] = clientAddr; &#125; try &#123; const response = await fetch(url, &#123;headers: headers&#125;); if (response &amp;&amp; response.status === 200) &#123; fontCSS = await response.text(); fontCSS = fontCSS.replace(/(https?:)?\\/\\/fonts\\.gstatic\\.com\\//mgi, &#x27;/fonts.gstatic.com/&#x27;); FONT_CACHE[cacheKey] = fontCSS; try &#123; if (cache) &#123; const cacheResponse = new Response(fontCSS, &#123;ttl: 86400&#125;); event.waitUntil(cache.put(cacheKeyRequest, cacheResponse)); &#125; &#125; catch(e) &#123;&#125; &#125; &#125; catch(e) &#123;&#125; &#125; return fontCSS;&#125;function getCacheKey(userAgent) &#123; let os = &#x27;&#x27;; const osRegex = /^[^(]*\\(\\s*(\\w+)/mgi; let match = osRegex.exec(userAgent); if (match) &#123; os = match[1]; &#125; let mobile = &#x27;&#x27;; if (userAgent.match(/Mobile/mgi)) &#123; mobile = &#x27;Mobile&#x27;; &#125; const edgeRegex = /\\s+Edge\\/(\\d+)/mgi; match = edgeRegex.exec(userAgent); if (match) &#123; return &#x27;Edge&#x27; + match[1] + os + mobile; &#125; const chromeRegex = /\\s+Chrome\\/(\\d+)/mgi; match = chromeRegex.exec(userAgent); if (match) &#123; return &#x27;Chrome&#x27; + match[1] + os + mobile; &#125; const webkitRegex = /\\s+AppleWebKit\\/(\\d+)/mgi; match = webkitRegex.exec(userAgent.match); if (match) &#123; return &#x27;WebKit&#x27; + match[1] + os + mobile; &#125; const firefoxRegex = /\\s+Firefox\\/(\\d+)/mgi; match = firefoxRegex.exec(userAgent); if (match) &#123; return &#x27;Firefox&#x27; + match[1] + os + mobile; &#125; return null;&#125; ç¾åœ¨å³å¯ä½¿ç”¨ï¼Œæ–¹æ³•æ˜¯ä¾‹å¦‚æˆ‘è¦è¨ªå•https://firebasestorage.googleapis.com/v0/b/mikuproject-e9478.appspot.com/o/mikuproject-files%2F404.png?alt=media&amp;token=40bb05e9-d925-48a4-b4f5-800a28153b92ç¾åœ¨åªè¦åœ¨é€£çµçš„https:&#x2F;&#x2F;å¾Œï¼ŒåŠ ä¸Šä½ çš„Workerçš„åŸŸåå³å¯æ›´æ”¹å¾Œçš„é€£çµè®Šç‚ºhttps://objectproxy.1205.moe/firebasestorage.googleapis.com/v0/b/mikuproject-e9478.appspot.com/o/mikuproject-files%2F404.png?alt=media&amp;token=40bb05e9-d925-48a4-b4f5-800a28153b92 ç¾æˆçš„ä½œæ¥­ Worker: https://objectproxy.1205.moe/"},{"title":"åœ¨Vueç¨‹å¼ä¸­ä½¿ç”¨Electronæ¡†æ¶","path":"2022/05/01/åœ¨Vueç¨‹åºä¸­ä½¿ç”¨Electronæ¡†æ¶/","text":"åœ¨Vueç¨‹å¼ä¸­ä½¿ç”¨Electronæ¡†æ¶ ä»Šå¤©ç¦¿ç„¶é‡åˆ°ä¸€å€‹éœ€æ±‚ï¼Œå³æ§‹å»ºè·¨å¹³å°çš„æ‡‰ç”¨ç¨‹å¼ï¼Œé‚£éº¼å°æ–¼æˆ‘ä¸€å€‹å…¨æ£§é–‹ç™¼ä¾†èªªï¼Œä½¿ç”¨Electronå°±æ˜¯æœ€å¥½çš„é¸æ“‡äº†ã€‚ ç­è§£ä¸€ä¸‹ï¼Œä»€éº¼æ˜¯Electron Electron æ˜¯ä¸€å€‹é–‹æº JavaScript æ¡†æ¶ï¼Œç”¨æ–¼ä½¿ç”¨ Web æŠ€è¡“ï¼ˆHTMLã€CSS å’Œ JavaScriptï¼‰æ§‹å»ºè·¨å¹³å°çš„æ‡‰ç”¨ç¨‹åºã€‚ é€™æ„å‘³è‘—å¦‚æœæ‚¨äº‹å…ˆç†Ÿæ‚‰ä½¿ç”¨é€™äº›æŠ€è¡“ï¼Œæ‚¨å¯ä»¥ç›´æ¥ä½¿ç”¨åŸå…ˆçš„æºä»£ç¢¼æ§‹å»ºæˆWindowsã€Linux å’Œ macOS çš„æ¡Œé¢æ‡‰ç”¨ç¨‹åºã€‚ èƒŒå¾Œï¼ŒElectron å°‡ Chromium å¼•æ“èˆ‡ Node.js é‹è¡Œæ™‚ç’°å¢ƒç›¸çµåˆï¼Œä¾†é‹è¡Œæ‚¨çš„ç¨‹å¼ã€‚ è€Œä¸”ï¼Œå·²æœ‰è¨±å¤šçŸ¥åä»¥Electronæ§‹å»ºçš„ç¨‹å¼ï¼Œæ¯”å¦‚ Slackã€VS Code å’Œ WhatsApp Desktopã€‚ é‚£éº¼ï¼Œä¾ç…§èˆ‡æˆ‘çš„æœ¬æ¬¡å¯¦è¸ï¼Œä¾†å‘Šè¨´å„ä½å°è²“å’ªå¦‚ä½•ä½¿ç”¨Electronæ§‹å»ºåŸºæ–¼Vueçš„App -&gt; 0ã€æœ€åŸºæœ¬çš„å®‰è£npmï¼ˆä¸éœ€è¦è¬›äº†å§wwwï¼‰ -&gt; 1ã€å®‰è£vue cli 1npm install -g @vue/cli å…¨å±€å®‰è£vue cli -&gt; 2ã€ä½¿ç”¨vue createæŒ‡ä»¤æ–°å»ºä¸€å€‹é …ç›® 1vue create your-project æ–°å»ºä¸€å€‹åå­—æ˜¯your-projectçš„é …ç›® -&gt; 3ã€ä½¿ç”¨vue addå‘½ä»¤æ–°å¢ä¸€å€‹æ’ä»¶ 1vue add electron-builder å°‡åå­—æ˜¯electron-builderçš„æ’ä»¶åŠ å…¥ä½ çš„é …ç›®!æ³¨æ„ï¼Œæ‚¨éœ€è¦cdå…¥æ‚¨çš„é …ç›®ç›®éŒ„å¾Œæ–¹å¯åŸ·è¡Œé€™æ¢å‘½ä»¤ -&gt; 4ã€é‹è¡Œç¨‹å¼ 1npm run electron:serve é–‹å•Ÿæ‡‰ç”¨ç¨‹å¼!æ³¨æ„ï¼Œæ‚¨éœ€è¦cdå…¥æ‚¨çš„é …ç›®ç›®éŒ„å¾Œæ–¹å¯åŸ·è¡Œé€™æ¢å‘½ä»¤!æ³¨æ„ï¼Œè‹¥æœ‰éŒ¯èª¤æ‚¨å¯ä»¥å˜—è©¦åŸ·è¡Œ npm i ç¾åœ¨å³å¯é€²è¡Œé–‹ç™¼ å¦‚ä½•æ‰“åŒ…æˆå¯ä»¥åˆ†ç™¼çš„æ‡‰ç”¨ç¨‹å¼å‘¢ï¼Ÿ å…¶å¯¦å¾ˆç°¡å–®ï¼Œåœ¨éœ€è¦æ‰“åŒ…æˆå°æ‡‰æ‡‰ç”¨ç¨‹å¼çš„å¹³å°å…§åŸ·è¡Œï¼š 1npm run electron:build ç¾åœ¨å³å¯å®Œæˆé€™å€‹æ‡‰ç”¨çš„é–‹ç™¼ï¼"},{"title":"è½‰ç¾©","path":"2022/04/13/è½‰ç¾©/","text":"è½‰ç¾© ç”±æ–¼å­¸ç¿’JavaScriptæ™‚æ˜¯ä¾ç…§å¯¦éš›æ¡ˆä¾‹ä¾†å­¸ç¿’çš„ï¼Œå› æ­¤éºæ¼äº†æŸäº›å°‘ç”¨åˆ°çš„æ–¹é¢ã€‚ æœ€è¿‘åœ¨å¯¦ç¾ä¸€å€‹éœ€æ±‚æ™‚ï¼Œç™¼ç¾è½‰ç¾©ç¬¦çœŸçš„è¶…å¥½ç”¨ï¼ï¼ä¸‹é¢æ˜¯éœ€æ±‚è©³æƒ…ï¼š -&gt;éœ€è¦å‘ä¼ºæœå™¨å…§å­˜å…¥htmlç‰‡æ®µï¼Œä¸¦ä¸”é€™äº›htmlç‰‡æ®µæœ‰è¡Œå…§æ¨£å¼ï¼Œå¦‚ä¸‹åœ– 12345&#123; &quot;title&quot;:&quot;SPRING&quot;, &quot;honor&quot;:&quot;&lt;span style=&#x27;color: blue;&#x27;&gt;SPRING&lt;/span&gt;&quot;, &quot;description&quot;:&quot;ä»£è¡¨æ‚¨åŠ å…¥äº†SPRINGè¨ˆç•«&quot;&#125; ç™¼ç¾å•é¡ŒğŸ¤”ï¼šåœ¨é€™è£å–®å¼•è™Ÿï¼Œé›™å¼•è™Ÿéƒ½ç”¨ä¸Šäº†ï¼Œé‚£éº¼è¦å¦‚ä½•æ‰èƒ½åœ¨SQLèªå¥å…§æ‹¼ä¸Šé€™æ®µå­—ç¬¦ä¸²å‘¢ï¼Ÿ è¶…ç´šé‡è¦ï¼ï¼ï¼ -&gt; SQLèªå¥éœ€è¦è¢«ä¸€å°å¼•è™Ÿæ‹¬èµ·ä¾†ã€‚ æœ‰çš„å°è²“å’ªå¯èƒ½å°±æœƒèªªäº†ï¼Œç”¨æ¨¡æ¿å­—ç¬¦ä¸²(``)ä¸å°±å¯ä»¥äº†å—ï¼Ÿ å…¶å¯¦æ˜¯ä¸è¡Œçš„ï¼Œè«‹çœ‹é€™å¼µåœ– é€™è£¡ä½¿ç”¨å–®å¼•è™Ÿã€é›™å¼•è™Ÿéƒ½æœƒå ±éŒ¯ -&gt; æ‰€ä»¥é€™è£¡çš„è§£æ±ºæ–¹æ¡ˆå°±æ˜¯ï¼šè½‰ç¾©ç¬¦è™Ÿçµ¦å‡ºæ­£ç¢ºçš„SQLèªå¥ 1UPDATE items SET itemValue =&#x27;&#123;&quot;title&quot;:&quot;SPRING&quot;,&quot;honor&quot;:&quot;&lt;span style=\\&#x27;color: blue;\\&#x27;&gt;SPRING&lt;/span&gt;&quot;,&quot;description&quot;:&quot;ä»£è¡¨æ‚¨åŠ å…¥äº†SPRINGè¨ˆç•«&quot;&#125;&#x27; WHERE itemKey=&quot;UID1*ActivatedHonor&quot; æˆåŠŸï¼"},{"title":"ç”¨csså¯¦ç¾ç¶²é é«˜æ–¯æ¨¡ç³Šç‰¹æ•ˆ","path":"2022/02/21/ç”¨csså¯¦ç¾ç¶²é é«˜æ–¯æ¨¡ç³ŠèƒŒæ™¯/","text":"ç”¨csså¯¦ç¾ç¶²é é«˜æ–¯æ¨¡ç³Šç‰¹æ•ˆ Attention: é€™ç¯‡æ–‡ç« æ¢è¨çš„æ˜¯å¦‚ä½•å¯¦ç¾èƒŒæ™¯é«˜æ–¯æ¨¡ç³Šï¼Œè€Œä¸æ˜¯æ•´å€‹è¦–åœ–é«˜æ–¯æ¨¡ç³Šï¼ï¼ï¼ å¤§æ¦‚æ•ˆæœæ˜¯é€™æ¨£ï¼š æ²’æœ‰é«˜æ–¯æ¨¡ç³Š ä½¿ç”¨é«˜æ–¯æ¨¡ç³Šæ•ˆæœ æ€éº¼æ¨£ï¼Ÿï¼Ÿæ˜¯ä¸æ˜¯æ„Ÿè¦ºå¥½æ¼‚äº®çš„æ•ˆæœï¼Œé‚£éº¼å¦‚ä½•å¯¦ç¾å‘¢(Â¯ï¸¶Â¯) å…ˆä¾†çœ‹çœ‹DOMçµæ§‹å…¶å¯¦æœ‰å…©ç¨®æ–¹æ³•ï¼Œé€™æ˜¯æ–¹æ³•ä¸€ï¼Œç›¸å®¹æ€§è¼ƒå¥½ï¼ -&gt; å¤–å±¤æœ‰ä¸€å€‹ id&#x3D;animeDetails çš„Divæ¨™ç±¤ï¼Œç”¨æ–¼æ’èµ·æ•´å€‹é é¢çš„é«˜åº¦123#animeDetails &#123; height: 100%;&#125; -&gt; å…§å±¤ä½¿ç”¨äº† class&#x3D;animeDetails_mask çš„ä¸€å€‹Divæ¨™ç±¤ç”¨æ–¼æ”¾å…¥è¦å±•ç¤ºçš„å…§å®¹ï¼Œä¾‹å¦‚ç¾åœ¨æˆ‘æ”¾å…¥çš„æ˜¯contentsé€™å¹¾å€‹å­—123456.animeDetails_mask &#123; position: relative; /* è®“é€™å€‹divèƒ½å¤ å æ»¿ç•«é¢ */ height: 100%; /* æ’èµ·æ•´å€‹é é¢çš„é«˜åº¦ */ overflow: hidden; /* æº¢å‡ºçš„å…§å®¹éš±è— */ z-index: 1; /* é«˜æ–¼å®ƒçš„å½å…ƒç´ é«˜åº¦ */&#125; -&gt; ç¾åœ¨é–‹å§‹è¨­å®šèƒŒæ™¯åœ–åŠé«˜æ–¯æ¨¡ç³Šï¼Œç”¨åˆ°äº†å½å…ƒç´ å”·ï¼ˆâ‰§âˆ‡â‰¦ï¼‰ 12345678910111213.animeDetails_mask::before &#123; content: &quot;&quot;; /* å½å…ƒç´ ä½¿ç”¨content: &quot;&quot;æŒ‡å®šå…§å®¹ç‚ºç©ºç™½ï¼Œä»¥ä¿æŒé€™å€‹å½å…ƒç´ å¯è¦‹ï¼ˆè¢«æ’é–‹äº†ï¼Œä¸ç„¶æ²’æœ‰å…§å®¹height=0ï¼‰ã€‚ */ position: absolute; /* è¨­å®šä½”æ»¿ç•«é¢ é–‹å§‹ */ top: -100px; left: -100px; right: -100px; bottom: -100px; /* è¨­å®šä½”æ»¿ç•«é¢ çµæŸ */ background-image: url(&quot;https://www.dmoe.cc/random.php&quot;); /* ç”¨ä¾†è¨­å®šèƒŒæ™¯åœ–ï¼Œé€™å€‹urlæ˜¯ä¸€å€‹å…è²»çš„éš¨æ©ŸäºŒæ¬¡å…ƒåœ–ç‰‡api */ background-repeat: no-repeat; /* è¨­å®šèƒŒæ™¯åœ–ç‚ºä¸é‡è¤‡ */ background-size: cover; /* è¨­å®šèƒŒæ™¯åœ–çš„å±•ç¤ºæ¨£å¼ */ filter: blur(16px); /* è¨­å®šé«˜æ–¯æ¨¡ç³Š16px */ z-index: -1; /* ä»¥å…æ“‹åˆ°æ–‡æœ¬ */ &#125; !!!çµ‚æ–¼ï¼Œå®Œæˆæƒ¹ï¼Œä¾†çœ‹çœ‹æ•ˆæœå§ å¥½åƒï¼ŒçœŸçš„æœ‰é«˜æ–¯æ¨¡ç³Šäº†ï¼Œä½†æ˜¯ç‚ºä»€éº¼åœ–æœƒä¸é€æ˜åº¦é€™éº¼ä½ï¼Œè®“æˆ‘æ€éº¼çœ‹å­—å•Šï¼ å°æƒ¹ï¼åœ¨ Div.animeDetails_mask ä¸Šè¨­å®šèƒŒæ™¯è‰²å°±å¥½äº†å§ï¼ ä¸ç®¡ç”¨æ¬¸ï¼Œé€™æ˜¯æ€éº¼å›äº‹å‘¢ï¼Ÿ å…¶å¯¦ç­”æ¡ˆå¾ˆç°¡å–®ï¼Œ ::before ä½¿ç”¨äº†position: absoluteï¼Œå·²ç¶“åœ¨æ–‡æª”æµæœ€ä¸Šæ–¹äº†ï¼Œæœƒå§å¾Œé¢çš„èƒŒæ™¯è‰²é®ä½ã€‚ è§£æ±ºæ–¹æ¡ˆå°±æ˜¯ï¼Œç”¨ ::after è¨­å®šèƒŒæ™¯è‰² 12345678910.animeDetails_mask::after &#123; content: &quot;&quot;; /* å½å…ƒç´ ä½¿ç”¨content: &quot;&quot;æŒ‡å®šå…§å®¹ç‚ºç©ºç™½ï¼Œä»¥ä¿æŒé€™å€‹å½å…ƒç´ å¯è¦‹ï¼ˆè¢«æ’é–‹äº†ï¼Œä¸ç„¶æ²’æœ‰å…§å®¹height=0ï¼‰ã€‚ */ position: absolute; /* è¨­å®šä½”æ»¿ç•«é¢ é–‹å§‹ */ top: -100px; left: -100px; right: -100px; bottom: -100px; /* è¨­å®šä½”æ»¿ç•«é¢ çµæŸ */ background-color: rgba(255, 255, 255, .9); /* è¨­å®šèƒŒæ™¯è‰²ï¼Œä¾†è®“é«˜æ–¯æ¨¡ç³Šèƒ½æœ‰ç™½è‰²çš„åº• */ z-index: -1; /* ä»¥å…æ“‹åˆ°æ–‡æœ¬ */&#125; -&gt; æˆæœé è¦½ å¦ä¸€ç¨®å¯¦ç¾æ–¹æ³•èˆ‡FireFoxä¸ç›¸å®¹ -&gt; çµ¦ #animeDetails è¨­å®šèƒŒæ™¯åœ–-&gt; çµ¦ .animeDetails_mask è¨­å®šæ¨£å¼ 1backdrop-filter: blur(16px); åŒæ¨£èƒ½å®Œæˆ"}]